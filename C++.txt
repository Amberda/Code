C++
C++ primer
Effective C++
C++编程思想
C++沉思录
深度探索C++对象模型
STL源码剖析----2/3
C++反汇编与逆向分析技术揭秘
程序员自我修养
C++11
boost库


C和C++的区别:编程模式: C-->面向过程   C++-->基于面向对象
	     关键字: C99  32个  C++98   63个
	     源文件后缀-->工程不同-->编译器-->语法
      	     语法不同:函数返回值类型(C语言不写默认返回为int，C++不写会报错) 
		      参数列表(C语言中没有参数就可以接收任意类型的参数，C++中不能
			       且C++参数列表支持缺省参数)
                      缺省参数:全缺省参数  半缺省参数(只能从右向左依次给出)
         		     缺省参数不能同时现在再声明和定义中，在声明处给出好一些
	     函数名称不同:C++支持函数重载(在同一作用域，几个功能类似的同名函数，参数列表不同，返回值不同)	  
	     extern "C"-->将extern "C"修饰的代码按照C语言风格编译    

引用: 1.什么是引用？  引用的概念，特点：
      2.引用和指针的区别？相同点，不同点
常饮用--const
引用使用场景:1.
	    2.函数传参-->const+引用
   	    3.返回值-->注意:不要返回栈内存的引用

命名空间：为了解决命名冲突
namespace N{}
相同的命名空间合并  可以嵌套  没有名称的命名空间中的变量相当于全局变量
命名空间中成员的使用规则：1.N::a
			 2.using N::a
			 3.using namespace N  有可能会冲突


类和对象  
 以C语言中的结构体过度
 类两种定义方式:1.
              2.返回值 类型::函数名(参数列表)
 访问限定符--->public  protected  private
 class 默认权限为private  struct默认为public
 在C和C++中struct的区别？
 在C++中，class和struct的区别？
 什么是封装？class+访问限定符
 类的作用域
 类的实例化
 对象模型:对象中各个成员的在内存中的布局格式？
 如何求类的大小？ 空类-->1
 编译器如何识别一个类？ 1.识别类名
		      2.识别类中的成员变量
		      3.识别类中的成员函数并对非静态成员函数进行改写(成员函数参数列表:还原this指针，改写函数体:非静态成员变量前面加this指针)

this指针:
 特性:1.this指针类型-->类类型* const
      2.只能在非静态成员函数体内使用
      3.编译器自动传递-->this_call:ecx寄存器  _cdecl:栈-->不定参数成员函数 
 this指针可以为空

类的6个默认成员函数    什么时候需要自己写一个构造函数 
		      什么时候系统会生成一个默认构造函数

构造函数
 概念   (普通的函数没有初始化列表) 
 性质: 不可以声明为虚函数...
 初始化列表 ---> 初始化(声明、赋初值)
	非静态成员变量只能被初始化一次，按照声明次序依次初始化。
	初始化列表中不可以使用this指针。
	必须在初始化列表中   const 引用 类类型的对象(必须有非缺省的构造函数)
 函数体--->赋值运算
 什么情况下编译器会合成构造函数?
	1.A 缺省的构造函数 B（A）没有显式定义构造函数 
	2.继承体系中  A继承B，B类有缺省的构造函数而A没有
	3.虚拟继承--->带参数  push 1
	4.类中有虚函数	
 构造函数是否有返回值？  this-->类类型* const-->当前对象的引用


拷贝构造函数
 概念:单参  类类型对象的引用(const) (AutoPtr中不能加const)
 性质:传参需要传引用  否则会导致没有出口的递归调用
 调用场景:用已经存在的对象来创建新对象
          Test t1();--->相当于函数声明，不会调用构造或者拷贝构造
  

析构函数
 概念:与构造函数功能相反
 性质:……
 调用场景: 销毁对象时调用


赋值运算符重载
 概念:  返回值 operator运算符(参数列表)  Test& operator=(const Test& t)
 前置++ Test& operator++()
 后置++ Test operator++(int)
 支持随机访问
  Test& operator[](size_t index)
  const T& operator[](size_t index)const
 迭代器
  T& operator*()
  T* operator->()
  bool operator==()
  bool operator!=()
 输出运算符
  1.类的成员函数  可以但是有缺陷-->调用是反的
  2.普通函数 ostream& operator<<(ostream& _cout,const T& t)
    可以，但不能在类外访问类中的私有成员
  3.友元函数 friend ostream& operator<<(ostream& _cout,const T& t)
 不能重载的运算符:
 友元
  概念:
  友元函数  友元类  破坏了封装性


取地址运算符重载


const修饰的取地址运算符重载


静态类成员
 在C语言中:static修饰变量:修饰初始化的全局变量 
			 修饰未初始化的全局变量
				具有文件作用域，存放位置不同
			 修饰初始化的局部变量
			 修饰未初始化的局部变量
				改变变量的生命周期，存放位置不同
                 修饰函数: 改变链接属性
 在C++中:static修饰类成员
         --->静态成员变量 
      		所有类对象共享  
      		类中声明，类外定义 
      		访问形式:对象.成员/类名::静态成员
     	 	sizeof()
      		不能出现在构造函数初始化列表
    	 --->静态成员函数
      		 静态成员函数和普通成员函数的区别？


const类成员
谈谈你对const的理解:
  C语言 const修饰变量-->内容不能被修改的变量
  C++ const修饰变量-->常量
		  -->具有宏常量的特性(编译时替换)
  const修饰成员变量:
  const修饰成员函数-->实际上是修饰this指针
  const成员函数和非const成员函数的区别?
  mutable与volatile


内联函数(&宏函数)
 声明和定义都放在类中
 用inline来修饰
 优缺点

C++动态内存管理:
 malloc/calloc/realloc区别？
 free

 new-->单个元素/new[]-->一段连续空间
 delete         delete[]
 new:申请空间 void* operator new(size_t size)
             -->malloc申请成功 返回 
		      申请失败 检测 内存不足 给出应对措施
     调用构造函数(选择性) 构造函数显式给出  编译器合成构造函数
 delete:调用析构函数(选择性)
        释放空间-->operator delete-->free
			(sizeof(T)*N+4)
 new T[N]:申请空间-->operator new[](size_t size)
		   -->operator new[](size_t size)-->malloc
        调用N次构造函数
 delete T[N]:从前四个字节取出N，析构N个对象资源 调用析构函数
 	    释放空间-->operator delete[](p)朝前偏移4个字节
		    -->operator delete(p)-->free
 malloc/free  new/delete  new[]/delete[]一定要匹配使用
 没有匹配使用是 正常使用？ 内存泄漏？ 崩溃？
 malloc/free与new/delete区别？
 如何进行内存泄漏检测？-->模拟实现内存泄露检测工具
 设计一个类，只能在栈上创建对象
 设计一个类，只能在堆上创建对象
 设计一个类，只能创建一个对象
 new操作符、操作符new-->重载
 定位new表达式:在已经存在的空间中调用构造函数来创建一个对象


深浅拷贝
 什么是深拷贝？什么是浅拷贝？
 class String
 {
  public:
	String(char* pStr="")
	String(const String& s)
	String& operator=(const String& s)
	~String()
 }
 最好给深拷贝  引用计数  写时拷贝


C++继承
 概念:
 好处:代码复用  实现多态
 class Base;
 class Derived:继承权限 Base
 继承权限和访问权限
 不同继承权限下，基类成员在派生类中的访问权限
 在继承体系中，基类和派生类中构造函数和析构函数的调用次序
 赋值兼容规则(public继承)
 对象模型
 基类中哪些成员可以被派生类继承？(构造 拷贝构造 析构 赋值运算符重载)
 同名隐藏:在继承体系中，基类和派生类中有相同的成员，
          如果派生类对象调用该成员，优先调派生类自己的成员
 不同继承体系下的对象模型(对象中各个成员在内存中的布局)
 单继承
 多继承
 菱形继承-->存在二义性问题
 虚拟继承-->虚拟继承和普通继承的区别
 菱形虚拟继承


《C++多态》
 概念:
 分类:静态多态  动态多态
 动态多态实现的条件:1.继承体系中，基类中要有虚函数且派生类中要对虚函数进行重写
 		   2.通过基类的引用或指针调用
 重写的概念:在继承体系中，基类中必须包含虚函数，如果在派生类中有函数和基类虚函	    数原型完全相同(协变和析构函数除外)，在派生类的虚表中会用派生类自            己的虚函数替换基类相同位置的虚函数
 动态实现原理
  虚表剖析-->简单动态多态的例子
  虚表的构造
 构造函数不能作为虚函数
 析构函数建议给成虚函数
 友元函数不能给成虚函数
 静态成员函数不能给成虚函数
 纯虚函数-->抽象类
 不同继承体系下带有虚函数的对象模型

 设计一个不能被继承的类。
 用C语言模拟继承
 用C语言模拟多态   (虚表类似数组，函数指针数组)
 用C语言模拟重载


《模板》

函数模板
1. 概念(关键字，作用域)
2. 参数推演--->隐式实例化
3. 模板函数如何编译
	1> 语法检测
	2> 生成代码
4. 模板参数列表---> 类型
                   类型参数    
		   非类型参数  int
5. 重载
6. 特化	(1.函数模板，2.特化)
7.模板的分离编译

类模板
1.STL ---
 	容器	vector list的使用场景，底层实现(区别) 
		deque forward_list
	迭代器	 iterator	对原生态的指针进行封装
		Find()
		接口的实现
		
	容器适配器  模板参数   		
			template<class T,class Con>  类类型
		    模板的模板参数	
			template<class T,template<class> Con> 模板类
		    栈(stack) vector 和队列(queue) list 的模拟实现
模板类的特化
 		全特化 
		偏特化 特化部分参数 / 让模板参数更加严格
		应用:类型萃取
		

《异常》
1.异常的抛出和捕获 throw(标记)抛出  try{} catch(类型) /基类类型/ 捕获
2.栈展开
抛出不捕获，程序崩溃
3.重新抛出 catch(...)   
		{throw;}
4.//不要再析构和构造中抛出异常，可能造成未定义行为
5.异常规范

《智能指针》
RAII 资源获取即初始化
auto_ptr 资源转移  /模拟实现
unique_ptr(scoped_ptr) 资源独占 /防拷贝
share_ptr (循环引用问题)	/模拟实现  线程安全问题
weak_ptr  (弱引用)
定制删除器  函数指针
  	    仿函数

类型转换
const_cast
static_cast
dynamic_cast
reinterpret_cast
RTTI::
explicit 在构造函数中禁止类型转换

  







	     